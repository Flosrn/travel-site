<<<<<<< HEAD
///<reference path='./typings/main.d.ts'/>
/*
 * gulp-svg2png
 *
 * Copyright(c) 2014 - present / André König <andre.koenig@posteo.de>
 * MIT Licensed
 *
 */
=======
/*
 * gulp-svg2png
 *
 * Copyright(c) 2014 André König <andre.koenig@posteo.de>
 * MIT Licensed
 *
 */

>>>>>>> master
/**
 * @author André König <andre.koenig@posteo.de>
 *
 */
<<<<<<< HEAD
'use strict';
var path = require('path');
var gutil = require('gulp-util');
var map_limit = require('map-stream-limit');
var map = require('map-stream');
var svg2png = require('svg2png');
var index_1 = require('./lib/index');
var PLUGIN_NAME = require('./package.json').name;
var Command = (function () {
    function Command(options, verbose) {
        if (options === void 0) { options = {}; }
        if (verbose === void 0) { verbose = true; }
        this.options = options;
        this.verbose = verbose;
    }
    /**
    * Wrapper around gutil logger.
    * Logs if logging is enabled.
    *
    * @param {string} message The log message
    *
    */
    Command.prototype.log = function (message) {
        if (this.verbose) {
            gutil.log(message);
        }
    };
    /**
    * Just a global error function.
    *
    * @param {string} message The error message
    *
    */
    Command.prototype.error = function (message) {
        throw new gutil.PluginError(PLUGIN_NAME, message);
    };
    /**
    * Renames the SVG file to a PNG file (extension)
    *
    * @param {string} filename The file name of the SVG
    *
    * @return {string} The file name with the PNG file extension.
    *
    */
    Command.prototype.rename = function (filename) {
        return filename.replace(path.extname(filename), '.png');
    };
    Command.prototype.execute = function (source, cb) {
        var _this = this;
        if (!source.isBuffer()) {
            return this.error('Streams are not supported by the underlying svg2png library.');
        }
        if (!index_1.SVG.is(source.contents)) {
            return this.error('Source is not a SVG file.');
        }
        svg2png(source.contents, this.options)
            .then(function (contents) {
            return cb(null, new gutil.File({
                base: source.base,
                path: _this.rename(source.path),
                contents: contents
            }));
        })
            .catch(function (err) {
            return cb(_this.error("Error while converting the image: " + err.message));
        });
    };
    return Command;
}());
module.exports = function (options, verbose, concurrency) {
    if (options === void 0) { options = {}; }
    if (verbose === void 0) { verbose = true; }
    if (concurrency === void 0) { concurrency = null; }
    var cmd = new Command(options, verbose);
    if (concurrency) {
        return map_limit(cmd.execute.bind(cmd), concurrency);
    }
    else {
        return map(cmd.execute.bind(cmd));
    }
};
=======

'use strict';

var path        = require('path'),
    os          = require('os'),
    fs          = require('fs'),
    map         = require('map-stream'),
    gutil       = require('gulp-util'),
    svg2png     = require('svg2png'),
    PLUGIN_NAME = 'gulp-svg2png';

/**
 * gulp-svg2png plugin
 *
 * @param {number} scale (optional) The scaling factor.
 * @param {boolean} verbose (optional) Should the progress be logged?
 *
 */
module.exports = function (scale, verbose) {

    if ('boolean' === typeof scale) {
        verbose = scale;
        scale = undefined;
    }

    scale = scale || 1.0;

    /**
     * Renames the SVG file to a PNG file (extension)
     *
     * @param {string} filename The file name of the SVG
     *
     * @return {string} The file name with the PNG file extension.
     *
     */
    function rename (filename) {
        return filename.replace(path.extname(filename), '.png');
    }

    /**
     * Just a global error function.
     *
     * @param {string} message The error message
     *
     */
    function error (message) {
        throw new gutil.PluginError(PLUGIN_NAME, message);
    }

    /**
     * Wrapper around gutil logger.
     * Logs if logging is enabled.
     *
     * @param {string} message The log message
     *
     */
    function log (message) {
        if (verbose) {
            gutil.log(message);
        }
    }

    /**
     * UUID generator
     *
     * @return {string} The generated UUID.
     *
     */
    function uuid () {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (chr) {
            var rand = Math.random() * 16|0;
            var value = chr == 'x' ? rand : (rand&0x3|0x8);

            return value.toString(16);
        });
    }

    /**
     * Checks if the given file is a SVG.
     *
     * @param  {buffer} svg The SVG file object.
     *
     * @return {Boolean}
     *
     */
    function isSVG (data) {
        var i = 0,
            len = data.length,
            snippet;

        data = data.toString('hex');

        for (i; i < len; i = i + 1) {
            snippet = data.slice(i, i + 2).toString('hex');

            if ('73' === snippet) {
                i = i + 2;
                snippet = data.slice(i, i + 2).toString('hex');

                if ('76' === snippet) {
                    i = i + 2;
                    snippet = data.slice(i, i + 2).toString('hex');

                    if ('67' === snippet) {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /**
     * Converts the source SVG file to a PNG.
     *
     * @param  {gutil.File} source The source SVG
     * @param  {function} cb
     *
     */
    function convert (source, cb) {
        var temp = path.join(os.tmpdir(), uuid() + '-' + rename(path.basename(source.path))),
            png;

        function done (err) {
            if (err) {
                return error(err);
            }

            log('Converted file: ' + png.path);

            cb(null, png);
        }

        function buffered (err, data) {
            png = new gutil.File({
                base: source.base,
                path: rename(source.path),
                contents: data
            });

            // Cleanup - Delete the temp file.
            fs.unlink(temp, done);
        }

        function converted (err) {
            if (err) {
                return error('Error while converting image.' + err);
            }

            fs.readFile(temp, buffered);
        }

        if (!isSVG(source.contents)) {
            return error('Source is not a SVG file.');
        }

        // Writes the file to the temp directory.
        svg2png(source.path, temp, scale, converted);
    }

    return map(convert);
};
>>>>>>> master
